---
draft  : true
title  : Writing Security Tests
author : Dinis Cruz
notes:
 - english and structure needs fixing
---

Writing Security Tests

When the security professional discloses a vulnerability, at that moment and time, we have a pure, typical, information asymmetric problem. Because you have a situation between the security professional and the developer, and it goes in both ways. 

So, first of all, not only the security professional doesn't fully understand the application, the implications of changes and what actually sometimes have behind the scenes. The developer doesn't understand, and don't have the full context and knowledge that the security professional has when he discovered the issue. Because, in a way, it's actually by definition, because the reason why the security professional finds these vulnerabilities, is because the developers were not aware of them, or were not aware of the implications, because by definition if they do, they won't do it, right? 

So, now we have a problem. Because the security professional finds an issue, and he has to report it. And the challenge is, how do you report a security vulnerability in the most efficient way? So, usually, you get a couple of screenshots, maybe a CRL, some kind of test on it, but the problem with that, is first of all, that is not a complete test. That is usually a variation of the problem, and usually, that is not easy to reproduce by developers. So, we have a situation, where a developer is supposed to fix a particular test, or a particular situation, where we don’t have full visibility on the implications, or even the variations of that test. 

So, my view is, what we need to do on that moment and time, is to write a series of tests. Let's call them, security tests. And these tests should represent the most efficient way to represent the security problems, across all the different effective layers. So, it actually means, in a traditional sense, that you might actually start with some integration, browse automation test, API automation, all the way to internal or more traditional unit tests, that will actually be able to pinpoint that particular issue. And sometimes, we even need to cross multiple layers and multiple tests to show that the problem exists, and actual multiple parts of the application. And then, once you write these tests, you need to package in a way, that the developer team can easily execute them. And that means, those tests have to be part of the developers’ pipeline, they have to be part of the production integration, because the tests have to be run every time there is a code change. And here is the catch! In order for that to exist, because we want the tests to basically provide evidence of the problem, and to represent the issue, and also provide a good example for the developers of what needs to be fixed. They need to pass, because those tests at the moment, they are capabilities of the application. The application has a capability, maybe sequel injection, maybe it's process scripting, maybe is an authentication problem. Fundamentally, they fact that the app allows, a) some data from a particular customer to be exposed, that is only one issue, that is supposed to be private. So, fundamentally, that's a feature of the application, it just becomes a vulnerability, the data is supposed to be private.

So, basically, what you then have, is a situation where we now provide information for developers to build directly and a test path, because it represents that capability, or that feature. And then, what happens is when the developers fix the problem, what they need to do. First of all, as soon as they fix the problem, the test fails. And this is already very interesting, because sometimes, when you provide multiple variations of the issue, sometimes, your issue fix, doesn't actually fix all of that. Which is actually quite interesting. So, then, you have a situation where once all those variations of the vulnerability have been fixed, all the tests that initially failed. Now, what you do, is that you change those tests, and usually change the name space of those tests, to becoming passing tests, when the vulnerability is fixed. So, in essence, what they do is they become regression tests. So, you are going to have a situation, you know that the security issue is actually fixed, because the tests now gives that proof.

This also allows you, for the cases, where sometimes you only fixed the vulnerability at one layer. Let's say you only fixed the vulnerability at the control level, but the internal web-services are still vulnerable, so in that case, you have tests that now passes, because it been fixed on the controller, but it also passes because it’s been vulnerable at the web-services layer, for example.

And that allow you to have a much more pragmatic understand of what is happening in, what is production, what is not in production. And this is a much more effective way of testing, because we are communicating. And that means, when the security consultant, or the security team gets asked, is this issue been fixed? The ideal situation, is that they should be able to review a test, and the test should be able to provide enough evident for to them to be comfortable to say, 'yes, it's been fixed'. Because if that test is not passing, I believe the application has been fixed for that particular vulnerability.  

Because what we are really trying to solve here, is that how do we effectively communicate between security professional, and share the security knowledge that exists in security consultants head, or even a tool, and the actual developers. And tests, security tests, for me are the most effective way of doing that. And this also means that you separate the moment where you fix, from the moment that you create the test. Because sometimes the biggest problem, in development, is to find that certain things are very hard to test, and security tends to be very good in finding those places. So, sometimes you have a big problem, if you are not able to test specific activities, that means that those area are not going to be well tested. And then, you have the evidence of them, in the vulnerability that have been discovered. So, the solution is not just to fix the issue, but to get to the root cause of the issue, a bigger one, which is actually the fact that, that area wasn't been tested properly.

